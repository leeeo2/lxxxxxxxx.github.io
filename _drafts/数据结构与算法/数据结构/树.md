# 二叉树的基本概念
## 二叉树   
二叉树是具有相同类型的数元素的集合，包含一个根和两个子树（左子树和右子树），且两个子树也是二叉树。
节点的度：节点拥有的子树个数成为节点的度，二叉树中，节点的度最大为2。
孩子、双亲、子孙、祖先、兄弟、堂兄弟。。。
层次：即第几层。
二叉树的度：二叉树中最大的节点的度。
二叉树的深度：二叉树中节点的最大层次数。

## 满二叉树   
所有分支节点都存在左右子树，且所有叶子都在同一层次。
完全二叉树：自上往下，自左往右从1开始编号，所有节点的编号与满二叉树一致的二叉树，是一颗完全二叉树（最下层叶子集中在左边）。

## 满二叉树   
所有分支节点都存在左右子树，且所有叶子都在同一层次。一棵非空二叉树第i层，最多有2^（i-1）个节点  

## 完全二叉树   
自上往下，自左往右从1开始编号，所有节点的编号与满二叉树一致的二叉树，是一颗完全二叉树（最下层叶子集中在左边）。

## 二叉查找树    
又称为二叉排序树、二叉搜索树，具有如下性质的树为二叉查找树：   
①	要么是一棵空树，否则   
②	若任意子节点左子树非空，则左子树上所有节点的值均小于根节点的值   
③	若任意子节点的右子树非空，则右子树所有节点的值均大于根节点的值   
④	任意子节点的左右子树也分别为二叉查找树   
⑤	没有值相等的节点   

由上述可得出，平衡二叉树的中序遍历（左中右）为升序序列，如果变为右中左就是降序序列，如剑指offer第54题——给定一棵二叉搜索树，请找出其中第k大的节点。可以将使用右中左的中序遍历，遍历第k个节点返回即可。


二叉查找树的查询复杂度和二分查找一样，插入和查找的时间复杂度均为 O(logn) ，但是在最坏的情况下仍然会有 O(n) 的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡，如下两种二叉查找树，其查找性能不可同日而语。
 

- 二叉查找树的操作主要有插入、删除、查找   
**插入**  
可以总结为，找叶子节点->插入

```
void myBinTree::Insert(int data){
	Node *tmp = new Node;
	tmp->data = data;
	tmp->lChild = tmp->rChild = nullptr;
	
	if (!m_root) {
		m_root = tmp;
		return;
	}
	Node *p = m_root;
	//找叶子节点
	while (1) {
		if (data < p->data){
			if (p->lChild) {
				p = p->lChild;
			}
			else {
				break;
			}
		}
		else{
			if (p->rChild) {
				p = p->rChild;
			}
			else {
				break;
			}
		}
	}
	//插入
	if (data < p->data) {
		p->lChild = tmp;
	}
	else{
		p->rChild = tmp;
	}
}
```

**查找**
```
Node* myBinTree::Search(int key) {
	Node *p = m_root;
	while (p) {
		if (key == p->data) {
			return p;
		}
		else if (key < p->data) {
			p = p->lChild;
		}
		else if (key > p->data) {
			p = p->rChild;
		}
	}
	return nullptr;
}
```

**删除**

```

```

## 平衡二叉树（AVL树）
AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis，在二叉搜索树的基础上，增加了高度限制，任何节点的左右子树的高度差不大于1。
AVL树插入或删除一个子节点后有可能失衡，存在四种情况LL,RR,LR,RL，其中LL表示根节点的左子树的左子树存在空节点导致左右子树高度差大于1，其他以此类推。

## 红黑树
红黑树，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)，树上的每个节点都遵循下面的规则:

- 每个节点都有红色或黑色
- 树的根始终是黑色的 (黑土地孕育黑树根， )
- 没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，并没有说不能出现连续的黑色节点）
- 从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点

## 平衡多路搜索树（B树）
B树的B是balance，不是二叉树，存在多个子节点，如m阶的B树有最多m个子节点。
任何节点的所有子节点高度差不大于1，常用于对查找效率要求较高的场景如数据库和磁盘分页查找。

B树的搜索机制：

以数据库为例，每个B树节点会将数据库主键分为多个段，根节点存储每个段的分界节点，每个段都有一个指针指向下一个节点（通常为磁盘block地址）。
首先读取根节点，然后使用二分查找算法找到目标所在分段，取出指针，从磁盘读取到下一个节点。

重复上一个步骤，直到找到目标为止。

其中每个节点的主键个数（阶数）受磁盘读取单位限制，一个block通常为4k，innoDB搜索引擎则将多个block连接起来作为一个单独读取单位（如16k），以增加每个节点的主键数，减少数的深度，提高搜索效率。

## B+树
B+树在B树的基础上针对查找做了一些改动，B树每个节点中主键对应的数据都存在节点中，这导致如果数据较大时，每个节点存放的主键数目会很少导致B树高度很大，性能大打折扣。

B+树则将节点分为索引节点（非叶子节点）和数据节点（叶子结点），索引节点只存键值，数据节点都存在叶子结点。

B+Tree相对于B-Tree有几点不同：
B+节点关键字搜索采用闭合区间
B+非叶节点不保存数据相关信息，只保存关键字和子节点的引用
B+关键字对应的数据保存在叶子节点中
B+叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系

