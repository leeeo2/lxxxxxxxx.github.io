# 滚动数组
在某些场景中，需要一个类似队列的方式，从尾部进入，头部出去，随着时间的推移循环向前，但是长度是固定的，我们用一个数组来表示。例如用四个int值得数组演示滚动数组。

```
int stack[4]；

for(int i=0;i<100;i++){
    stack[0]=stack[1];
    stack[1]=stack[2];
    stack[2]=stack[3];
    stack[3]=i;
}
```

例题：一个人上台阶可以一次跨一级或两级，问一个n级的台阶，有多少种方式能上到顶。
分析：利用动态规划的思想，站在第i级台阶，他有两种方式到达这里，从第i-1级台阶或i-2级台阶上来，可以得到递推公式
f(i)=f(i-1)+f(i-2)
边界条件：f(0)=1;f(1)=1

由分析可得，我们需要轮询计算每一级台阶的到达方式，而计算每一级台阶的到达方式需要记录第i-1和i-2级的结果，我们当然可以每一级都新建一个变量取存储，但是最后的结果我们只需要知道倒数第一二级的结果就行了，前面的结果记录下来是没有意义的。
这里就可以用滚动数组的思想，来将空间复杂度降到O(1)。

解答：


# 动态规划
动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

动态规划的关键是划分问题元素，找到问题元素的通用状态、各元素之间的转移方式以及边界条件，

通用状态即每一个元素都有的状态，可能不止一种。

转移方式是元素间的状态转移，可以是相邻元素间的转移（即i与i-1间的关系），或跨多个元素间的转移，思考的时候先考虑相邻元素间的转移，无法解决时，再思考跨元素间的转移。这些转移方式一般存在多种，问题一般也是找多种转移方式的最佳组合。

边界条件即初始值，状态转移我们肯定需要知道一个初始值，否则无法完成转移，一般第一、第二个问题元素可求出初始值。

##### 如leetcode 122题. 买卖股票的最佳时机 II    

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

- 示例 1:

> 输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

- 示例 2:

> 输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3:

> 输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
 

- 提示：
1 <= prices.length <= 3 * 10 ^ 4
0 <= prices[i] <= 10 ^ 4

###### 分析
这类数组类的问题，一般问题元素就是数组元素的具体描述，这个问题中一天就是一个问题元素。

然后思考问题元素的通用状态，即每个元素都有的状态，这个问题中，每一天都有两种状态，即持有或不持有股票。（这里容易想歪，以为卖出或不卖出为通用状态，但是买卖是动作，不是状态，这里需要小心）

接下来就是思考问题元素间状态如何转移，在这个问题中，首先考虑相邻元素间的转移。且每天都有两种状态，切转移需要分开处理：

首先假设第i天不持有股票，第i-1天可能持有或不持有股票，如果第i-1天不持有，那么第i天的最大收益和第i-1天是一样的（因为我们dii天也不持有，这是我们的假设，看第一句）；如果第i-1天持有，由于第i天已经假设不持有，所有要把它卖掉，获得收益price[i]，再这两种转移方式中求最大值
再假设第i天持有股票，那么当第i-1天不持有股票时，收益为-prices[i] (相当于支持了prices[i])；当第i-1天持有股票，收益也和第i-1天一样，因为从持有到持有，也没有卖，所有收益一样。

至于边界条件，第一天持有为-prices，不持有为0.

在这四种转移状态中，取最大的一个，就是第i天的最大收益

我们用0表示不持有股票，1表示持有，用dp[i][0]来表示第i天不持有股票的最大收益，dp[i][1]表示持有股票的最大收益，显然dp[0][0]=0，dp[0][1]=-prices[0]

如下是GO语言实现：
```
func maxProfit(prices []int) int {
    size:=len(prices)
    if size==1{
        return 0
    }
    dp:=make([][2]int,size)
    dp[0][0]=0
    dp[0][1]=-prices[0]
    for i:=1;i<size;i++{
        dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])
        dp[i][1]=max(dp[i-1][0]-prices[i],dp[i-1][1])
    }
    return dp[size-1][0]
}

func max(i,j int)int{
    if i>j{
        return i
    }
    return j
}
```


# 位运算



# 递归

# 滑动窗口

# 有限状态机

